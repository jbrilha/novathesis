%!TEX root = ../../template.tex

\section{System Model}
\label{sec:system_model}

\gls{ubabel} is structured as a layered architecture where components interact
to achieve autonomous multi-protocol operation. This section presents the key
architectural components organized into four functional layers: Core
Components, Discovery \& Topology, Coordination, and Data Management.

Figure~\ref{fig:system_architecture}
illustrates the overall component organization and interactions.

\todo{figure out onde meter o event dispatcher?}
% trim=left bottom right top,
\begin{figure}[htbp]
	\centering
	\includegraphics[width=\linewidth, trim=2cm 10cm 10cm 1cm, clip]{2-MainMatter/chapter3_sections/arch_components.pdf}
	\caption{System architecture and component interactions}
	\label{fig:system_architecture}
\end{figure}

\subsection{Core Components Layer}
\label{subsec:core_infra}

\todo{mix entre o que temos e o que podemos vir a ter}
The Core Components Layer provides the foundational services for protocol
management, event dispatching, and connection handling. These components
abstract protocol heterogeneity and provide unified interfaces to higher
layers.

\subsubsection*{Protocol Manager}
\label{component:protocol_manager}

The Protocol Manager maintains runtime information for all available
communication protocols and device capabilities. It registers available
protocols during system initialization and tracks their operational status
throughout device operation, simultaneously making decisions on adaptive
selection based on current operational conditions.

Key responsibilities include:
(1) Registering protocol handlers and their characteristics (range,
throughput, energy cost);
(2) Tracking which protocols are supported on each device based on
hardware capabilities;
(3) Enabling or disabling protocols dynamically based on runtime
conditions (e.g., battery level, interference detection);
(4) Selecting the appropriate protocol(s) for messages based on
\gls{QoS}, device capabilities, energy budget and environmental
conditions, all while preventing excessive oscillation through
switching cost awareness

% Key responsibilities include:
% \begin{itemize}
% 	\item Registering protocol handlers and their characteristics (range,
% 	      throughput, energy cost)
% 	\item Tracking which protocols are supported on each device based on
% 	      hardware capabilities
% 	\item Enabling or disabling protocols dynamically based on runtime
% 	      conditions (e.g., battery level, interference detection)
% 	\item Selecting the appropriate protocol(s) for messages based on
% 	      \gls{QoS}, device capabilities, energy budget and environmental
% 	      conditions, all while preventing excessive oscillation through
% 	      switching cost awareness
% \end{itemize}

\subsubsection*{Event Dispatcher}
\label{component:event_dispatcher}

The Event Dispatcher implements an event-driven coordination model that
decouples components and enables asynchronous communication between services.
Components register interest in specific event types and subtypes, and the
dispatcher routes incoming events to all registered subscribers.

This approach prevents tight coupling between protocol implementations and
application logic, enabling independent development and testing of individual
components while maintaining system-wide coordination.

\subsubsection*{Communication Manager}
\label{component:communication_manager}

The Communication Manager provides protocol-agnostic virtual connection state
tracking and high-level abstractions for peer communication. Applications and
system components interact with remote nodes using \glspl{UUID} rather than
protocol-specific addresses.

For each virtual connection, the manager:
(1) Maintains \gls{UUID}-to-protocol mappings;
(2) Monitors per-protocol link availability;
(3)	Determines message routing by querying the Topology Manager;
(4) Hands messages to the Message Queue Manager with routing decisions.

% For each virtual connection, the manager:
% \begin{itemize}
%     \item Maintains \gls{UUID}-to-protocol mappings
% 	\item Monitors per-protocol link availability
% 	\item Determines message routing by querying the Topology Manager
% 	\item Hands messages to the Message Queue Manager with routing decisions
% \end{itemize}

This unified abstraction enables higher-layer components to interact with peers
without concerning themselves with protocol-specific details.

\subsection{Discovery \& Topology Layer}
\label{subsec:discovery_topology}
\todo{wishful thinking}

The Discovery \& Topology Layer handles peer discovery, network topology
maintenance, and multi-hop routing. These components enable autonomous network
formation without centralized coordination.

\subsubsection*{Peer Discovery Service}
\label{component:peer_discovery}

The Peer Discovery Service implements multi-protocol neighbor discovery.
Short-range protocols like \gls{BLE}, \gls{ESP-NOW}, and \gls{ZigBee} employ
active discovery mechanisms (i.e., advertising, peer lists, beacons), while
long-range \gls{LoRa} communication relies on opportunistic message exchange.

The service discovers peers and provides standardized information to the
Topology Manager by: (1) Periodically scanning for neighbor advertisements and
beacons across active protocols; (2) Advertising local device capabilities
(supported protocols, computational resources, battery status); (3) Translating
protocol-specific discovery information into standardized peer descriptors for
the Topology Manager.

% The service discovers peers and provides standardized information to the
% Topology Manager by:
% \begin{itemize}
% 	\item Periodically scanning for neighbor advertisements and beacons across
% 	      active protocols
% 	\item Advertising local device capabilities (supported protocols,
% 	      computational resources, battery status)
% 	\item Translating protocol-specific discovery information into standardized
% 	      peer descriptors for the Topology Manager
% \end{itemize}

\subsubsection*{Topology Manager}
\label{component:topology_manager}

Inspired by HyParView~\cite{hyparview2007}, the Topology Manager maintains
hybrid partial views for scalability and resilience. Each node keeps a small
\emph{active view} of peers with which it maintains active communication links,
and a larger \emph{passive view} serving as a pool of potential neighbors.

The active view is managed reactively: nodes are added during join operations
and removed upon failure detection. The passive view is maintained through
periodic shuffle operations that exchange peer descriptors with neighbors,
providing view diversity without global knowledge.

Key operations include:
(1) Managing peer membership in active and passive views;
(2) Passive view shuffling for backup peer discovery;
(3) Providing routing decisions to Communication Manager;
(4) Automatic peer promotion from passive to active view upon failures;

% Key operations include:
% \begin{itemize}
% 	\item Managing peer membership in active and passive views
% 	\item Passive view shuffling for backup peer discovery
% 	\item Providing routing decisions to Communication Manager
% 	\item Automatic peer promotion from passive to active view upon failures
% \end{itemize}

\subsection{Coordination Layer}
\label{subsec:coordination}
\todo{wishful thinking too}

The Coordination Layer manages time synchronization,
enabling coordinated operation without master nodes.

\subsubsection*{Synchronization Service}
\label{component:decentralized_sync}

Coordinated multi-protocol operation requires time synchronization for channel
hopping and scheduled communication windows. The Synchronization Service
implements decentralized consensus on clock values through randomized gossip,
inspired by \gls{RGCS}~\cite{rgcs2018}.

Each node maintains a logical clock composed of rate and offset parameters that
transform its hardware clock into synchronized logical time. Synchronization
occurs through gossip exchanges using Poisson-distributed
\todo{explicar melhor what I mean by Poisson-distributed?}
intervals to minimize collision probability, with sync partners selected from
the Topology Manager's active view. Sync messages can also be piggybacked on
the Topology Manager's shuffle exchanges to reduce communication overhead.

Key aspects include:
(1) Per-protocol Poisson gossip rates accounting for protocol-specific energy
costs and reliability; (2) Converge-to-max criterion for faster convergence
than average-based approaches; (3) Simultaneous rate and offset compensation;
(4) Multi-protocol operation where sync messages can be sent over any available
protocol.

% Key aspects include:
% \begin{itemize}
% 	\item Per-protocol Poisson gossip rates accounting for protocol-specific
% 	      energy costs and reliability
% 	\item Converge-to-max criterion for faster convergence than average-based
% 	      approaches
% 	\item Simultaneous rate and offset compensation
% 	\item Multi-protocol operation where sync messages can be sent over any
% 	      available protocol
% \end{itemize}

Unlike master-based synchronization that creates single points of failure, this
gossip-based approach maintains synchronization through distributed local
interactions.

\subsection{Data Management Layer}
\label{subsec:data_management}
\todo{wishful thinking too$^2$}

The Data Management Layer optimizes data transmission through compression and
efficient queue management, extending operational lifetime in battery-powered
deployments.

\subsubsection*{Compression Service}
\label{component:reduction_compression}

The Compression Service reduces transmission overhead through prediction-based
data reduction (inspired by Ambrosia~\cite{ambrosia2021}) and lightweight
compression (inspired by Sprintz~\cite{sprintz2018} and the approach
in~\cite{twotier2019}). It employs window-based forecasting where sensor values
are transmitted only when prediction error exceeds application-specific
thresholds.

Both sender and receiver maintain synchronized prediction state, ensuring
consistency without additional communication overhead. The service supports:
(1) Prediction-based reduction with configurable error thresholds ($\delta$);
(2) Protocol-aware threshold adaptation (higher thresholds for energy-expensive protocols);
(3) Lightweight time-series compression using delta coding, zigzag encoding, and \gls{RLE};
(4) Graceful degradation under low battery conditions.

% Both sender and receiver maintain synchronized prediction state, ensuring
% consistency without additional communication overhead. The service supports:
% \begin{itemize}
% 	\item Prediction-based reduction with configurable error thresholds
% 	      ($\delta$)
% 	\item Protocol-aware threshold adaptation (higher thresholds for
% 	      energy-expensive protocols)
% 	\item Lightweight time-series compression using delta coding, zigzag
% 	      encoding, and \gls{RLE}
% 	\item Graceful degradation under low battery conditions
% \end{itemize}

Protocol-specific compression strategies account for varying energy costs: data
transmitted over \gls{LoRa} may employ more aggressive compression than
\gls{BLE} transmissions, balancing compression overhead against transmission
savings.

\subsubsection*{Message Queue Manager}
\label{component:message_queue}

The Message Queue Manager handles all message transmission scheduling. It
receives routing decisions from the Communication Manager and coordinates with
the Protocol Manager to determine when messages can actually be transmitted. It
maintains separate queues for different message priorities (e.g., critical
alerts, periodic sensor data, opportunistic synchronization) and enforces
memory limits based on device capabilities.

Responsibilities include:
(1) Priority-based queuing with configurable policies;
(2) Store-and-forward buffer management for partitioned networks;
(3) Per-protocol transmission scheduling based on protocol availability;
(4) Delivery confirmation tracking and retransmission scheduling;
(5) Message aging awareness;.

% Responsibilities include:
% \begin{itemize}
% 	\item Priority-based queuing with configurable policies
% 	\item Store-and-forward buffer management for partitioned networks
% 	\item Per-protocol transmission scheduling based on protocol availability
% 	\item Delivery confirmation tracking and retransmission scheduling
% 	\item Message aging awareness
% \end{itemize}

\subsection{Component Interactions}
\label{subsec:component_interactions}

% Figure~\ref{fig:system_architecture} illustrates the interactions between
% components.
% The Communication Manager is the top-level abstraction for application
% interaction, it receives user messages and processes them according to
% their type, available protocols, and known topology.

Peer Discovery continuously feeds neighbor information to the Topology Manager,
which maintains active/passive views and provides topology information to the
Communication Manager for routing decisions. The Communication Manager then
hands messages to the Message Queue Manager for immediate transmission or
buffering based on those decisions.

The Message Queue Manager coordinates with the Protocol Manager to schedule
actual transmission by querying for protocol availability and managing the
transmission timing, the Compression Service then acts upon outbound messages
prior to actual transmission, performing data reduction if the message type and
transmission method allow for or require it.

The Synchronization Service coordinates with the Protocol Manager to prevent
protocol switching during synchronization exchanges, and selects sync partners
from the Topology Manager's active view. Additionally, it can opportunistically
coordinate during shuffle events by piggybacking synchronization information
on peer description exchanges, thus reducing the total gossip overhead.

The Event Dispatcher orchestrates asynchronous inter-component communication,
enabling loosely coupled interactions through event publication and
subscription, simplifying component development and incremental system
evolution.
