%!TEX root = ../../template.tex

\section{Decentralized Synchronization and Time Coordination}
\label{sec:decentralized_sync}

Multi-channel communication strategies, particularly those that employ
coordinated channel hopping for security or efficiency reasons, require nodes
to maintain synchronized clocks. Without time synchronization, devices cannot
agree on when to switch channels, rendering coordinated multi-protocol
operation unfeasible.

Traditional master-based synchronization approaches -- where a designated
coordinator is responsible for communicating timing signals -- once more fall
into the limitation of having a single point of failure in that same master
node: should it fail, the entire network becomes susceptible to losing accurate
temporal reference, leading to the collapse of any coordination efforts.

This is a notorious challenge when designing distributed systems,
and it becomes more prominent in the disaster scenarios discussed thus far,
where infrastructure failures are likely to eliminate the nodes responsible for
time synchronization in a given system. Achieving robust time synchronization
in such situations requires fully decentralized approaches that eliminate
central coordinator dependencies while still remaining sufficiently lightweight
to be executed on resource-constrained platforms.

\subsection{Master-Based Synchronization as Counterexample}
\label{subsec:master_sync}

Time synchronization in distributed networks is frequently implemented through
beacon or master-clock schemes due to their precision and implementation
simplicity.
As discussed in Section~\ref{subsec:multi-channel}, the MCSC-WoT
framework~\cite{mcsc-wot} demonstrates a security-focused multi-channel hopping
approach aimed at embedded platforms, but with a fundamental dependency on a
master node broadcasting synchronization signals.

This approach uses a shared \gls{PRNG} seed to generate channel-hopping
sequences, with the coordinator node broadcasting periodic synchronization
beacons that participant nodes use to compensate for clock drift. Nodes that
lose synchronization altogether can rejoin by hopping to a random channel and
waiting for the next coordinator beacon.

While the proposed goals were achieved in terms of minimizing energy
expenditure and maintaining \gls{FHSS} patterns, it inherits the fundamental
limitation of all master-based approaches mentioned at the start of
Section~\ref{sec:decentralized_sync}. If the master fails or becomes unreachable,
participating nodes gradually drift out of synchronization until coordinated
channel hopping is no longer possible.

The system's clock drift compensation algorithm demonstrates the feasibility of
synchronization on ESP32 platforms, and their measured \gls{AES} encryption
performance validates that lightweight security can coexist with time
synchronization on resource-constrained devices. However, the architectural
dependency on a central coordinator fundamentally conflicts with
infrastructure-independent operation requirements we aim to fulfill.

\subsection{Gossip-Based Masterless Synchronization}
\label{subsec:gossip_sync}

Decentralized time synchronization eliminates coordinator dependencies by
having nodes reach consensus on clock values through distributed local
interactions. Two complementary approaches demonstrate the viability of
gossip-based synchronization for \glspl{WSN}.\\

The \gls{RGCS} algorithm proposed
in~\cite{rgcs2018} addresses time synchronization in dynamic \glspl{WSN} through
randomized asynchronous gossip. Each node maintains a logical clock (T)
composed of rate ($\alpha$) and offset ($\beta$) parameters, which together transform the
node's hardware clock ($\tau$) into synchronized logical time.

Rather than requiring fixed communication links between specific node pairs
which might be fragile in dynamic topologies, their approach uses Poisson-based
randomized link activation where each potential synchronization link activates
with intensity $\lambda$.

The synchronization process operates through pairwise gossip exchanges: when a
link activates, the triggering node sends a Sync-L beacon selecting a triggered
neighbor, followed by bidirectional exchange of multivariable messages
containing each node's current logical clock parameters [$\alpha, \beta, \tau$].

The asynchronous randomized timing of these exchanges is advantageous in that
collision rates drop to near zero compared to 19-23\% for deterministic
communication protocols, as independent Poisson intervals make simultaneous
transmissions to the same receiver statistically unlikely.

The proposed \gls{RGCS} employs a converge-to-max criterion rather than average-value
consensus. This maximum-based approach achieves finite time convergence
significantly faster than average-based protocols that require many iterations
to converge under significant clock drift. Offset compensation follows suit,
with nodes adjusting $\beta$ parameters based on the difference between their
and the neighbors' logical clocks.

Bounded communication delays are handled through a least-square estimation
low-pass filter.This addresses the realistic concern of uplink and downlink
delays differing, and avoids the symmetric delay assumptions made by many
theoretical protocols. The filter's weighing parameter decreases over time, in
order to restrain the negative effects of additive noise in stochastic
approximation.

Storage complexity remains O($|N_i|$) per node per iteration (proportional only
to the number of neighbors, not network size) thus ensuring scalability. The
protocol simultaneously compensates both clock rate and offset, unlike
approaches that handle these separately and thus require additional convergence
time.

\subsection{Coordination Through Passive View Maintenance}
\label{subsec:coord_passive}

As discussed in Section~\ref{subsec:peer_disc}, the shuffle-based passive view
maintenance presented in HyParView~\cite{hyparview2007} provides a
complementary coordination mechanism. While primarily designed for topology
management, the periodic shuffle operations in which nodes exchange lists of
known peers can also provide a \emph{catalog} of potential synchronization
partners beyond their immediate active neighbors.

Nodes performing shuffle exchanges already communicate periodically; these same
communication windows can opportunistically carry synchronization messages
(piggybacking), reducing protocol overhead. The passive view serves as a pool
of potential sync partners, so that when a node's active sync neighbors become
unreachable, it can initiate sync exchanges with passive view members,
providing added resilience to topology changes without requiring global network
knowledge.

\subsection{Discussion}
\label{subsec:rw_discussion_4}

Coordinator-based synchronization approaches like MCSC-WoT~\cite{mcsc-wot}
demonstrate feasibility on ESP32 platforms with measured \gls{AES} encryption
coexistence, but create single points of failure when master nodes become
unreachable.

\gls{RGCS}~\cite{rgcs2018} eliminates coordinator dependencies, and provides
converge-to-max synchronization with Poisson-based randomized gossip that
achieves near-zero collision rates with just O($|N_i|$) storage complexity per
node. However, it assumes homogeneous single-protocol networks where all nodes
use the same communication medium with identical energy characteristics and
range properties.

HyParView's~\cite{hyparview2007} shuffle-based passive view maintenance could
provide complementary coordination through periodic peer exchanges carrying
piggybacked sync messages, but was not designed for time synchronization. One
example would be when a node receives a shuffle message containing peer
descriptors (IDs and capabilities): it can evaluate these peers as candidates
for time synchronization based on their advertised characteristics -- for
instance, prioritizing peers with access to \gls{NTP} or \gls{GPS} clock
synchronization.\\

We have found no work that addresses decentralized time synchronization across
heterogeneous multi-protocol networks where different communication
technologies (\gls{BLE}, \gls{LoRa}, Wi-Fi) have distinct energy costs, range,
and reliability properties that warrant protocol-specific gossip rates.

% \gls{ubabel}'s approach (Section~\ref{component:decentralized_sync}) will
% strive to extend \gls{RGCS} to multi-protocol scenarios with per-protocol
% Poisson processes while preventing protocol selection oscillations during sync
% events.
